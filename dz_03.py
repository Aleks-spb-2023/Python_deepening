

friends = {'alecs':('рюкзак','котелок', 'посуда', 'спички', 'одежда'),
           'igor':('рюкзак', 'еда', 'палатка', 'удочки', 'одежда'),
            'artur':('одежда', 'магнитофон', 'вода', 'фонарик', 'аптечка')}

# какие вещи взяли все три друга
print(*[x for row in friends.values() for x in row], sep='\n')

#какие вещи уникальны для каждого друга
keys = list(friends.keys())
al = set(friends['alecs'])
ig = set(friends['igor'])
art = set(friends['artur'])
print(*al - ig - art)
print(*ig - art - al)
print(*art - al - ig)

#какие вещи есть у всех друзей кроме одного и имя того, у кого данная вещь отсутствует

print(al.union(ig) - art, "Таких вещей нет у",keys[2])
print(ig.union(art) - al, "Таких вещей нет у",keys[0])
print(art.union(al) - al, "Таких вещей нет у",keys[1])

print('---------------------------------')
#Дан список повторяющихся элементов. Вернуть список с дублирующимися элементами.
# В результирующем списке не должно быть дубликатов

lst = [1, 4, 67, 1, 5, 9, 9, 5, 0, 6, 11, 4]
lst2 = []
for i in lst:
    if lst.count(i) > 1:
        lst2.append(i)
print(list(set(lst2)))

print("________________________________________")
#В большой текстовой строке подсчитать количество встречаемых слов и вернуть 10 самых частых.
# Не учитывать знаки препинания и регистр символов.
# За основу возьмите любую статью из википедии или из документации к языку.

string = " высокоуровневый язык программирования общего назначения с динамической строгой типизацией" \
         " и автоматическим управлением памятью, ориентированный на повышение производительности " \
         "разработчика, читаемости кода и его качества," \
         " а также на обеспечение переносимости написанных на нём программ. " \
         "Язык является полностью объектно-ориентированным в том плане, что всё является объектами." \
         " Необычной особенностью языка является выделение блоков кода пробельными отступами." \
         " Синтаксис ядра языка минималистичен, за счёт чего на практике редко возникает" \
         " необходимость обращаться к документации. Сам же язык известен как интерпретируемый " \
         "и используется в том числе для написания скриптов. Недостатками языка являются" \
         " зачастую более низкая скорость работы и более высокое потребление памяти написанных " \
         "на нём программ по сравнению с аналогичным кодом, написанным на компилируемых языках," \
         " таких как C или C++"


string_correct = [i.rstrip() for i in string.split()]
str_dictionary = {}

for i in string_correct:
    str_dictionary[i] = str_dictionary.get(i, 0) + 1
res = {k: v for k, v in sorted(str_dictionary.items(), key=lambda item: item[1], reverse=True)}
for n , s in enumerate(res, 1):
    if n > 10:
        break
    print(s)

print('___________________________')

#Создайте словарь со списком вещей для похода в качестве ключа и их массой в качестве значения.
# Определите какие вещи влезут в рюкзак передав его максимальную грузоподъёмность.
# Достаточно вернуть один допустимый вариант. *Верните все возможные варианты комплектации рюкзака.



stuff = {'matches': 1, 'cup': 2, 'tent': 10, 'ration': 5, 'spare shoes': 3}

def backpack_capacity(capacity: int, stuff: dict) -> list[str]:
    packaging_option = []
    summary = []
    for key, value in stuff.items():
        if value <= capacity:
            capacity -= value
            packaging_option.append(key)
    return packaging_option


print(backpack_capacity(15, stuff))
